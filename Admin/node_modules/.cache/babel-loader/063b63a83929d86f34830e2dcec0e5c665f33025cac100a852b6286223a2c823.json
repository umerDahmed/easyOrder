{"ast":null,"code":"","map":{"version":3,"names":[],"sources":["C:\\Users\\bond\\Desktop\\major project\\EasyOrder\\Admin\\node_modules\\@antv\\g-base\\src\\interfaces.ts"],"sourcesContent":["import {\n  ShapeCfg,\n  GroupCfg,\n  ClipCfg,\n  Renderer,\n  Point,\n  ChangeType,\n  AnimateCfg,\n  ElementAttrs,\n  OnFrame,\n  ShapeBase,\n  BBox,\n  ElementFilterFn,\n  Cursor,\n  LooseObject,\n} from './types';\nimport GraphEvent from './event/graph-event';\n\nexport interface ICtor<T> {\n  new (cfg: any): T;\n}\n\n/**\n * @interface IObservable\n * 可以绑定事件的接口\n */\nexport interface IObservable {\n  /**\n   * 绑定事件\n   * @param  eventName 事件名\n   * @param callback  回调函数\n   */\n  on(eventName: string, callback: Function);\n  /**\n   * 移除事件\n   */\n  off();\n  /**\n   * 移除事件\n   * @param eventName 事件名\n   */\n  off(eventName: string);\n  /**\n   * 移除事件\n   * @param eventName 事件名\n   * @param callback  回调函数\n   */\n  off(eventName: string, callback: Function);\n  /**\n   * 触发事件, trigger 的别名函数\n   * @param eventName 事件名称\n   * @param eventObject 参数\n   */\n  emit(eventName: string, eventObject: object);\n\n  getEvents(): any;\n}\n\n/**\n * @interface IBase\n * 所有图形类公共的接口，提供 get,set 方法\n */\nexport interface IBase extends IObservable {\n  cfg: LooseObject;\n  /**\n   * 获取属性值\n   * @param  {string} name 属性名\n   * @return {any} 属性值\n   */\n  get(name: string): any;\n  /**\n   * 设置属性值\n   * @param {string} name  属性名称\n   * @param {any}    value 属性值\n   */\n  set(name: string, value: any);\n\n  /**\n   * 是否销毁\n   * @type {boolean}\n   */\n  destroyed: boolean;\n\n  /**\n   * 销毁对象\n   */\n  destroy();\n}\n\n/**\n * @interface\n * 图形元素的基类\n */\nexport interface IElement extends IBase {\n  /**\n   * 获取父元素\n   * @return {IContainer} 父元素一般是 Group 或者是 Canvas\n   */\n  getParent(): IContainer;\n\n  /**\n   * 获取所属的 Canvas\n   * @return {ICanvas} Canvas 对象\n   */\n  getCanvas(): ICanvas;\n\n  /**\n   * 获取 Shape 的基类\n   * @return {IShape} Shape 的基类，用作工厂方法来获取类实例\n   */\n  getShapeBase(): ShapeBase;\n\n  /**\n   * 获取 Group 的基类，用于添加默认的 Group\n   * @return {IGroup} group 类型\n   */\n  getGroupBase(): ICtor<IGroup>;\n\n  /**\n   * 当引擎画布变化时，可以调用这个方法，告知 canvas 图形属性发生了改变\n   * 这个方法一般不要直接调用，在实现 element 的继承类时可以复写\n   * @param {ChangeType} changeType 改变的类型\n   */\n  onCanvasChange(changeType: ChangeType);\n\n  /**\n   * 是否是分组\n   * @return {boolean} 是否是分组\n   */\n  isGroup(): boolean;\n  /**\n   * 从父元素中移除\n   * @param {boolean} destroy 是否同时销毁\n   */\n  remove(destroy?: boolean);\n  /**\n   * 获取全量的图形属性\n   */\n  attr();\n  /**\n   * 获取图形属性\n   * @param {string} name 图形属性名\n   * @returns 图形属性值\n   */\n  attr(name: string): any;\n  /**\n   * 设置图形属性\n   * @param {string} name  图形属性名\n   * @param {any}    value 图形属性值\n   */\n  attr(name: string, value: any);\n  /**\n   * 设置图形属性\n   * @param {object} attrs 图形属性配置项，键值对方式\n   */\n  attr(attrs: object);\n  /**\n   * 获取包围盒，这个包围盒是相对于图形元素自己，不会计算 matrix\n   * @returns {BBox} 包围盒\n   */\n  getBBox();\n  /**\n   * 获取图形元素相对画布的包围盒，会计算从顶层到当前的 matrix\n   * @returns {BBox} 包围盒\n   */\n  getCanvasBBox(): BBox;\n  /**\n   * 复制对象\n   */\n  clone(): IElement;\n  /**\n   * 显示\n   */\n  show();\n  /**\n   * 隐藏\n   */\n  hide();\n  /**\n   * 设置 zIndex\n   */\n  setZIndex(zIndex: number);\n  /**\n   * 最前面\n   */\n  toFront();\n  /**\n   * 最后面\n   */\n  toBack();\n  /**\n   * 清除掉所有平移、旋转和缩放\n   */\n  resetMatrix();\n  /**\n   * 获取 transform 后的矩阵\n   * @return {number[]} 矩阵\n   */\n  getMatrix(): number[];\n  /**\n   * 设置 transform 的矩阵\n   * @param {number[]} m 应用到图形元素的矩阵\n   */\n  setMatrix(m: number[]);\n  /**\n   * 将向量应用设置的矩阵\n   * @param {number[]} v 向量\n   */\n  applyToMatrix(v: number[]);\n  /**\n   * 根据设置的矩阵，将向量转换相对于图形/分组的位置\n   * @param {number[]} v 向量\n   */\n  invertFromMatrix(v: number[]);\n\n  /**\n   * 是否处于动画暂停状态\n   * @return {boolean} 是否处于动画暂停状态\n   */\n  isAnimatePaused();\n\n  /**\n   * 执行动画\n   * @param {ElementAttrs} toAttrs 动画最终状态\n   * @param {number}       duration 动画执行时间\n   * @param {string}       easing 动画缓动效果\n   * @param {function}     callback 动画执行后的回调\n   * @param {number}       delay 动画延迟时间\n   */\n  animate(toAttrs: ElementAttrs, duration: number, easing?: string, callback?: Function, delay?: number);\n\n  /**\n   * 执行动画\n   * @param {OnFrame}  onFrame  自定义帧动画函数\n   * @param {number}   duration 动画执行时间\n   * @param {string}   easing   动画缓动效果\n   * @param {function} callback 动画执行后的回调\n   * @param {number}   delay    动画延迟时间\n   */\n  animate(onFrame: OnFrame, duration: number, easing?: string, callback?: Function, delay?: number);\n\n  /**\n   * 执行动画\n   * @param {ElementAttrs} toAttrs 动画最终状态\n   * @param {AnimateCfg}   cfg     动画配置\n   */\n  animate(toAttrs, cfg: AnimateCfg);\n\n  /**\n   * 执行动画\n   * @param {OnFrame}    onFrame 自定义帧动画函数\n   * @param {AnimateCfg} cfg     动画配置\n   */\n  animate(onFrame, cfg: AnimateCfg);\n\n  /**\n   * 停止图形的动画\n   * @param {boolean} toEnd 是否到动画的最终状态\n   */\n  stopAnimate(toEnd?: boolean);\n\n  /**\n   * 暂停图形的动画\n   */\n  pauseAnimate();\n\n  /**\n   * 恢复暂停的动画\n   */\n  resumeAnimate();\n\n  /**\n   * 设置 clip ，会在内部转换成对应的图形\n   * @param {ClipCfg} clipCfg 配置项\n   */\n  setClip(clipCfg: ClipCfg);\n\n  /**\n   * 获取 clip ，clip 对象是一个 Shape\n   * @returns {IShape} clip 的 Shape\n   */\n  getClip(): IShape;\n\n  /**\n   * 指定的点是否被裁剪掉\n   * @param  {number}  refX 相对于图形的坐标 x\n   * @param  {number}  refY 相对于图形的坐标 Y\n   * @return {boolean} 是否被裁剪\n   */\n  isClipped(refX: number, refY: number): boolean;\n\n  /**\n   * 触发委托事件\n   * @param  {string}  type 事件类型\n   * @param  {GraphEvent}  eventObj 事件对象\n   */\n  emitDelegation(type: string, eventObj: GraphEvent): void;\n\n  /**\n   * 移动元素\n   * @param {number} translateX x 轴方向的移动距离\n   * @param {number} translateY y 轴方向的移动距离\n   * @return {IElement} 元素\n   */\n  translate(translateX: number, translateY?: number): IElement;\n\n  /**\n   * 移动元素到目标位置\n   * @param {number} targetX 目标位置的 x 轴坐标\n   * @param {number} targetY 目标位置的 y 轴坐标\n   * @return {IElement} 元素\n   */\n  move(targetX: number, targetY: number): IElement;\n\n  /**\n   * 移动元素到目标位置，等价于 move 方法。由于 moveTo 的语义性更强，因此在文档中推荐使用 moveTo 方法\n   * @param {number} targetX 目标位置的 x 轴坐标\n   * @param {number} targetY 目标位置的 y 轴坐标\n   * @return {IElement} 元素\n   */\n  moveTo(targetX: number, targetY: number): IElement;\n\n  /**\n   * 缩放元素\n   * @param {number} ratio 各个方向的缩放比例\n   * @return {IElement} 元素\n   */\n  scale(ratio: number): IElement;\n\n  /**\n   * 缩放元素\n   * @param {number} ratioX x 方向的缩放比例\n   * @param {number} ratioY y 方向的缩放比例\n   * @return {IElement} 元素\n   */\n  scale(ratioX: number, ratioY: number): IElement;\n\n  /**\n   * 以画布左上角 (0, 0) 为中心旋转元素\n   * @param {number} radian 旋转角度(弧度值)\n   * @return {IElement} 元素\n   */\n  rotate(radian: number): IElement;\n\n  /**\n   * 以起始点为中心旋转元素\n   * @param {number} radian 旋转角度(弧度值)\n   * @return {IElement} 元素\n   */\n  rotateAtStart(rotate: number): IElement;\n\n  /**\n   * 以任意点 (x, y) 为中心旋转元素\n   * @param {number} radian 旋转角度(弧度值)\n   * @return {IElement} 元素\n   */\n  rotateAtPoint(x: number, y: number, rotate: number): IElement;\n}\n\nexport interface IContainer extends IElement {\n  /**\n   * 添加图形\n   * @param {ShapeCfg} cfg  图形配置项\n   * @returns 添加的图形对象\n   */\n  addShape(cfg: ShapeCfg): IShape;\n\n  /**\n   * 添加图形\n   * @param {string} type 图形类型\n   * @param {ShapeCfg} cfg  图形配置项\n   * @returns 添加的图形对象\n   */\n  addShape(type: string, cfg: ShapeCfg): IShape;\n\n  /**\n   * 容器是否是 Canvas 画布\n   */\n  isCanvas();\n\n  /**\n   * 添加图形分组，增加一个默认的 Group\n   * @returns 添加的图形分组\n   */\n  addGroup(): IGroup;\n\n  /**\n   * 添加图形分组，并设置配置项\n   * @param {GroupCfg} cfg 图形分组的配置项\n   * @returns 添加的图形分组\n   */\n  addGroup(cfg: GroupCfg): IGroup;\n\n  /**\n   * 添加图形分组，指定类型\n   * @param {IGroup} classConstructor 图形分组的构造函数\n   * @param {GroupCfg} cfg 图形分组配置项\n   * @returns 添加的图形分组\n   */\n  addGroup(classConstructor: IGroup, cfg: GroupCfg): IGroup;\n\n  /**\n   * 根据 x,y 获取对应的图形\n   * @param {number} x x 坐标\n   * @param {number} y y 坐标\n   * @param {Event} 浏览器事件对象\n   * @returns 添加的图形分组\n   */\n  getShape(x: number, y: number, ev: Event): IShape;\n\n  /**\n   * 添加图形元素，已经在外面构造好的类\n   * @param {IElement} element 图形元素（图形或者分组）\n   */\n  add(element: IElement);\n\n  /**\n   * 获取父元素\n   * @return {IContainer} 父元素一般是 Group 或者是 Canvas\n   */\n  getParent(): IContainer;\n\n  /**\n   * 获取所有的子元素\n   * @return {IElement[]} 子元素的集合\n   */\n  getChildren(): IElement[];\n\n  /**\n   * 子元素按照 zIndex 进行排序\n   */\n  sort();\n\n  /**\n   * 清理所有的子元素\n   */\n  clear();\n\n  /**\n   * 获取第一个子元素\n   * @return {IElement} 第一个元素\n   */\n  getFirst(): IElement;\n\n  /**\n   * 获取最后一个子元素\n   * @return {IElement} 元素\n   */\n  getLast(): IElement;\n\n  /**\n   * 根据索引获取子元素\n   * @return {IElement} 第一个元素\n   */\n  getChildByIndex(index: number): IElement;\n\n  /**\n   * 子元素的数量\n   * @return {number} 子元素数量\n   */\n  getCount(): number;\n\n  /**\n   * 是否包含对应元素\n   * @param {IElement} element 元素\n   * @return {boolean}\n   */\n  contain(element: IElement): boolean;\n\n  /**\n   * 移除对应子元素\n   * @param {IElement} element 子元素\n   * @param {boolean} destroy 是否销毁子元素，默认为 true\n   */\n  removeChild(element: IElement, destroy?: boolean);\n\n  /**\n   * 查找所有匹配的元素\n   * @param  {ElementFilterFn} fn 匹配函数\n   * @return {IElement[]} 元素数组\n   */\n  findAll(fn: ElementFilterFn): IElement[];\n\n  /**\n   * 查找元素，找到第一个返回\n   * @param  {ElementFilterFn} fn 匹配函数\n   * @return {IElement|null} 元素，可以为空\n   */\n  find(fn: ElementFilterFn): IElement;\n\n  /**\n   * 根据 ID 查找元素\n   * @param {string} id 元素 id\n   * @return {IElement | null} 元素\n   */\n  findById(id: string): IElement;\n\n  /**\n   * 该方法即将废弃，不建议使用\n   * 根据 className 查找元素\n   * TODO: 该方法暂时只给 G6 3.3 以后的版本使用，待 G6 中的 findByClassName 方法移除后，G 也需要同步移除\n   * @param {string} className 元素 className\n   * @return {IElement | null} 元素\n   */\n  findByClassName(className: string): IElement;\n\n  /**\n   * 根据 name 查找元素列表\n   * @param {string}      name 元素名称\n   * @return {IElement[]} 元素\n   * 是否是实体分组，即对应实际的渲染元素\n   * @return {boolean} 是否是实体分组\n   */\n  findAllByName(name: string): IElement[];\n}\n\nexport interface IGroup extends IElement, IContainer {\n  /**\n   * 是否是实体分组，即对应实际的渲染元素\n   * @return {boolean} 是否是实体分组\n   */\n  isEntityGroup(): boolean;\n}\n\nexport interface IShape extends IElement {\n  /**\n   * 图形拾取\n   * @param {number} x x 坐标\n   * @param {number} y y 坐标\n   * @returns 是否已被拾取\n   */\n  isHit(x: number, y: number): boolean;\n  /**\n   * 是否用于 clip, 默认为 false\n   * @return {boolean} 图形是否用于 clip\n   */\n  isClipShape(): boolean;\n}\n\n/**\n * @interface ICanvas\n * 画布，图形的容器\n */\nexport interface ICanvas extends IContainer {\n  /**\n   * 获取当前的渲染引擎\n   * @return {Renderer} 返回当前的渲染引擎\n   */\n  getRenderer(): Renderer;\n\n  /**\n   * 为了兼容持续向上查找 parent\n   * @return {IContainer} 返回元素的父容器，在 canvas 中始终是 null\n   */\n  getParent(): IContainer;\n\n  /**\n   * 获取画布的 cursor 样式\n   * @return {Cursor}\n   */\n  getCursor(): Cursor;\n\n  /**\n   * 设置画布的 cursor 样式\n   * @param {Cursor} cursor  cursor 样式\n   */\n  setCursor(cursor: Cursor);\n\n  /**\n   * 改变画布大小\n   * @param {number} width  宽度\n   * @param {number} height 高度\n   */\n  changeSize(width: number, height: number);\n\n  /**\n   * 根据事件对象获取画布坐标\n   * @param  {Event} ev 事件对象\n   * @return {object} 画布坐标\n   */\n  getPointByEvent(ev: Event): Point;\n\n  /**\n   * 根据事件对象获取窗口坐标\n   * @param  {Event} ev 事件对象\n   * @return {object} 窗口坐标\n   */\n  getClientByEvent(ev: Event): Point;\n\n  /**\n   * 将窗口坐标转变成画布坐标\n   * @param  {number} clientX 窗口 x 坐标\n   * @param  {number} clientY 窗口 y 坐标\n   * @return {object} 画布坐标\n   */\n  getPointByClient(clientX: number, clientY: number): Point;\n\n  /**\n   * 将 canvas 坐标转换成窗口坐标\n   * @param {number} x canvas 上的 x 坐标\n   * @param {number} y canvas 上的 y 坐标\n   * @returns {object} 窗口坐标\n   */\n  getClientByPoint(x: number, y: number): Point;\n\n  /**\n   * 绘制\n   */\n  draw();\n}\n"],"mappings":""},"metadata":{},"sourceType":"script","externalDependencies":[]}