{"ast":null,"code":"import * as _ from '@antv/util';\nimport { DEFAULT_Y } from '../constant';\nvar Adjust = /** @class */function () {\n  function Adjust(cfg) {\n    var xField = cfg.xField,\n      yField = cfg.yField,\n      _a = cfg.adjustNames,\n      adjustNames = _a === void 0 ? ['x', 'y'] : _a,\n      dimValuesMap = cfg.dimValuesMap;\n    this.adjustNames = adjustNames;\n    this.xField = xField;\n    this.yField = yField;\n    this.dimValuesMap = dimValuesMap;\n  }\n  /**\n   * 查看维度是否是 adjust 字段\n   * @param dim\n   */\n  Adjust.prototype.isAdjust = function (dim) {\n    return this.adjustNames.indexOf(dim) >= 0;\n  };\n  Adjust.prototype.getAdjustRange = function (dim, dimValue, values) {\n    var yField = this.yField;\n    var index = values.indexOf(dimValue);\n    var length = values.length;\n    var pre;\n    var next;\n    // 没有 y 字段，但是需要根据 y 调整\n    if (!yField && this.isAdjust('y')) {\n      pre = 0;\n      next = 1;\n    } else if (length > 1) {\n      // 如果以其开头，则取之，否则取他前面一个\n      pre = values[index === 0 ? 0 : index - 1];\n      // 如果以其结尾，则取之，否则取他后面一个\n      next = values[index === length - 1 ? length - 1 : index + 1];\n      if (index !== 0) {\n        pre += (dimValue - pre) / 2;\n      } else {\n        pre -= (next - dimValue) / 2;\n      }\n      if (index !== length - 1) {\n        next -= (next - dimValue) / 2;\n      } else {\n        next += (dimValue - values[length - 2]) / 2;\n      }\n    } else {\n      pre = dimValue === 0 ? 0 : dimValue - 0.5;\n      next = dimValue === 0 ? 1 : dimValue + 0.5;\n    }\n    return {\n      pre: pre,\n      next: next\n    };\n  };\n  Adjust.prototype.adjustData = function (groupedDataArray, mergedData) {\n    var _this = this;\n    // 所有调整维度的值数组\n    var dimValuesMap = this.getDimValues(mergedData);\n    // 按照每一个分组来进行调整\n    _.each(groupedDataArray, function (dataArray, index) {\n      // 遍历所有数据集合\n      // 每个分组中，分别按照不同的 dim 进行调整\n      _.each(dimValuesMap, function (values, dim) {\n        // 根据不同的度量分别调整位置\n        _this.adjustDim(dim, values, dataArray, index);\n      });\n    });\n  };\n  /**\n   * 对数据进行分组adjustData\n   * @param data 数据\n   * @param dim 分组的字段\n   * @return 分组结果\n   */\n  Adjust.prototype.groupData = function (data, dim) {\n    // 补齐数据空数据为默认值\n    _.each(data, function (record) {\n      if (record[dim] === undefined) {\n        record[dim] = DEFAULT_Y;\n      }\n    });\n    // 按照 dim 维度分组\n    return _.groupBy(data, dim);\n  };\n  /** @override */\n  Adjust.prototype.adjustDim = function (dim, values, data, index) {};\n  /**\n   * 获取可调整度量对应的值\n   * @param mergedData 数据\n   * @return 值的映射\n   */\n  Adjust.prototype.getDimValues = function (mergedData) {\n    var _a = this,\n      xField = _a.xField,\n      yField = _a.yField;\n    var dimValuesMap = _.assign({}, this.dimValuesMap);\n    // 所有的维度\n    var dims = [];\n    if (xField && this.isAdjust('x')) {\n      dims.push(xField);\n    }\n    if (yField && this.isAdjust('y')) {\n      dims.push(yField);\n    }\n    dims.forEach(function (dim) {\n      if (dimValuesMap && dimValuesMap[dim]) {\n        return;\n      }\n      // 在每个维度上，所有的值\n      dimValuesMap[dim] = _.valuesOfKey(mergedData, dim).sort(function (v1, v2) {\n        return v1 - v2;\n      });\n    });\n    // 只有一维的情况下，同时调整 y，赋予默认值\n    if (!yField && this.isAdjust('y')) {\n      var dim = 'y';\n      dimValuesMap[dim] = [DEFAULT_Y, 1]; // 默认分布在 y 轴的 0 与 1 之间\n    }\n\n    return dimValuesMap;\n  };\n  return Adjust;\n}();\nexport default Adjust;","map":{"version":3,"names":["_","DEFAULT_Y","Adjust","cfg","xField","yField","_a","adjustNames","dimValuesMap","prototype","isAdjust","dim","indexOf","getAdjustRange","dimValue","values","index","length","pre","next","adjustData","groupedDataArray","mergedData","_this","getDimValues","each","dataArray","adjustDim","groupData","data","record","undefined","groupBy","assign","dims","push","forEach","valuesOfKey","sort","v1","v2"],"sources":["C:\\Users\\bond\\Desktop\\major project\\EasyOrder\\Admin\\node_modules\\@antv\\adjust\\src\\adjusts\\adjust.ts"],"sourcesContent":["import * as _ from '@antv/util';\nimport { DEFAULT_Y } from '../constant';\nimport { AdjustCfg, Data, Range } from '../interface';\n\nexport type AdjustConstructor = new (cfg: any) => Adjust;\n\nexport interface DimValuesMapType {\n  [dim: string]: number[];\n}\n\nexport default abstract class Adjust {\n  /** 参与调整的维度 */\n  public adjustNames: string[];\n  /** x 维度对应的字段 */\n  public xField: string;\n  /** y 维度对应的字段 */\n  public yField: string;\n\n  // Dodge 属性\n  /** 调整占单位宽度的比例，例如：占 2 个分类间距的 1 / 2 */\n  public dodgeRatio: number;\n  /** 调整过程中 2 个数据的间距，以 dodgeRatio 为分母 */\n  public marginRatio: number;\n  /** 指定进行 dodge 的字段 */\n  public dodgeBy: string;\n  /** 自定义 offset */\n  public customOffset: ((data: any, range: any) => number) | number;\n\n  // Stack 属性\n  public height: number;\n  public size: number;\n  public reverseOrder: boolean;\n\n  /** 像素级组间距 */\n  public intervalPadding: number;\n  /** 像素级组内间距 */\n  public dodgePadding: number;\n  /** x维度长度，计算归一化padding使用 */\n  public xDimensionLegenth: number;\n  /** 分组数 */\n  public groupNum: number;\n\n  // 图形宽度相关配置\n  /** 用户配置宽度 */\n  public defaultSize: number;\n  /** 最大宽度约束 */\n  public maxColumnWidth: number;\n  /** 最小宽度约束 */\n  public minColumnWidth: number;\n  /** 宽度比例 */\n  public columnWidthRatio: number;\n\n  /** 用户自定义的dimValuesMap */\n  public dimValuesMap: DimValuesMapType;\n\n  constructor(cfg: AdjustCfg & { dimValuesMap?: DimValuesMapType }) {\n    const { xField, yField, adjustNames = ['x', 'y'], dimValuesMap } = cfg;\n\n    this.adjustNames = adjustNames;\n    this.xField = xField;\n    this.yField = yField;\n    this.dimValuesMap = dimValuesMap;\n  }\n\n  // 需要各自实现的方法\n  public abstract process(dataArray: Data[][]): Data[][];\n\n  /**\n   * 查看维度是否是 adjust 字段\n   * @param dim\n   */\n  public isAdjust(dim: string): boolean {\n    return this.adjustNames.indexOf(dim) >= 0;\n  }\n\n  protected getAdjustRange(dim: string, dimValue: number, values: number[]): Range {\n    const { yField } = this;\n\n    const index = values.indexOf(dimValue);\n    const length = values.length;\n\n    let pre;\n    let next;\n\n    // 没有 y 字段，但是需要根据 y 调整\n    if (!yField && this.isAdjust('y')) {\n      pre = 0;\n      next = 1;\n    } else if (length > 1) {\n      // 如果以其开头，则取之，否则取他前面一个\n      pre = values[index === 0 ? 0 : index - 1];\n      // 如果以其结尾，则取之，否则取他后面一个\n      next = values[index === length - 1 ? length - 1 : index + 1];\n\n      if (index !== 0) {\n        pre += (dimValue - pre) / 2;\n      } else {\n        pre -= (next - dimValue) / 2;\n      }\n\n      if (index !== length - 1) {\n        next -= (next - dimValue) / 2;\n      } else {\n        next += (dimValue - values[length - 2]) / 2;\n      }\n    } else {\n      pre = dimValue === 0 ? 0 : dimValue - 0.5;\n      next = dimValue === 0 ? 1 : dimValue + 0.5;\n    }\n\n    return {\n      pre,\n      next,\n    };\n  }\n\n  protected adjustData(groupedDataArray: Data[][], mergedData: Data[]) {\n    // 所有调整维度的值数组\n    const dimValuesMap = this.getDimValues(mergedData);\n\n    // 按照每一个分组来进行调整\n    _.each(groupedDataArray, (dataArray, index) => {\n      // 遍历所有数据集合\n      // 每个分组中，分别按照不同的 dim 进行调整\n      _.each(dimValuesMap, (values: number[], dim: string) => {\n        // 根据不同的度量分别调整位置\n        this.adjustDim(dim, values, dataArray, index);\n      });\n    });\n  }\n\n  /**\n   * 对数据进行分组adjustData\n   * @param data 数据\n   * @param dim 分组的字段\n   * @return 分组结果\n   */\n  protected groupData(data: Data[], dim: string): { [dim: string]: Data[] } {\n    // 补齐数据空数据为默认值\n    _.each(data, (record: Data) => {\n      if (record[dim] === undefined) {\n        record[dim] = DEFAULT_Y;\n      }\n    });\n\n    // 按照 dim 维度分组\n    return _.groupBy(data, dim);\n  }\n\n  /** @override */\n  protected adjustDim(dim: string, values: number[], data: Data[], index?: number): void {}\n\n  /**\n   * 获取可调整度量对应的值\n   * @param mergedData 数据\n   * @return 值的映射\n   */\n  private getDimValues(mergedData: Data[]): DimValuesMapType {\n    const { xField, yField } = this;\n\n    const dimValuesMap: DimValuesMapType = _.assign({}, this.dimValuesMap);\n\n    // 所有的维度\n    const dims = [];\n    if (xField && this.isAdjust('x')) {\n      dims.push(xField);\n    }\n    if (yField && this.isAdjust('y')) {\n      dims.push(yField);\n    }\n\n    dims.forEach((dim: string): void => {\n      if (dimValuesMap && dimValuesMap[dim]) {\n        return;\n      }\n      // 在每个维度上，所有的值\n      dimValuesMap[dim] = _.valuesOfKey(mergedData, dim).sort((v1, v2) => v1 - v2) as number[];\n    });\n\n    // 只有一维的情况下，同时调整 y，赋予默认值\n    if (!yField && this.isAdjust('y')) {\n      const dim = 'y';\n      dimValuesMap[dim] = [DEFAULT_Y, 1]; // 默认分布在 y 轴的 0 与 1 之间\n    }\n\n    return dimValuesMap;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}